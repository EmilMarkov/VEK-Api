// Code generated by Prisma Client Rust. DO NOT EDIT

pub static DATAMODEL_STR : & 'static str = include_str ! ("/Users/emilmarkov/dev/rust/VEK-Api/prisma/schema.prisma") ; static DATABASE_STR : & 'static str = "sqlite" ; use :: prisma_client_rust :: migrations :: include_dir ; pub static MIGRATIONS_DIR : & :: prisma_client_rust :: migrations :: include_dir :: Dir = & :: prisma_client_rust :: migrations :: include_dir :: include_dir ! ("/Users/emilmarkov/dev/rust/VEK-Api/prisma/migrations") ; pub async fn new_client () -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { PrismaClient :: _builder () . build () . await } pub async fn new_client_with_url (url : & str) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { PrismaClient :: _builder () . with_url (url . to_string ()) . build () . await } pub mod user { use super :: * ; use super :: _prisma :: * ; pub const NAME : & str = "User" ; pub mod id { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "id" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Id (direction) } pub fn equals < T : From < UniqueWhereParam >> (value : String) -> T { UniqueWhereParam :: IdEquals (value) . into () } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod login { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "login" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetLogin (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Login (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Login (direction) } pub fn equals < T : From < UniqueWhereParam >> (value : String) -> T { UniqueWhereParam :: LoginEquals (value) . into () } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Login , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Login (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Login (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod updated_at { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "updated_at" ; pub struct Set (pub :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetUpdatedAt (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UpdatedAt (v) } } pub fn set < T : From < Set >> (value : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: UpdatedAt (direction) } pub fn equals (value : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> WhereParam { WhereParam :: UpdatedAt (_prisma :: read_filters :: DateTimeFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: DateTimeFilter , UpdatedAt , { fn in_vec (_ : Vec < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > >) -> InVec ; fn not_in_vec (_ : Vec < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > >) -> NotInVec ; fn lt (_ : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> Lt ; fn lte (_ : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> Lte ; fn gt (_ : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> Gt ; fn gte (_ : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> Gte ; fn not (_ : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UpdatedAt (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UpdatedAt (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod yandex_auth { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "yandexAuth" ; pub struct Fetch (pub yandex_auth :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < yandex_auth :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: YandexAuth (v) } } pub fn fetch () -> Fetch { Fetch (yandex_auth :: UniqueArgs :: new ()) } pub struct Connect (yandex_auth :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectYandexAuth (v) } } pub fn connect < T : From < Connect >> (value : yandex_auth :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectYandexAuth } pub fn is_null () -> WhereParam { WhereParam :: YandexAuthIsNull } pub fn is (value : Vec < yandex_auth :: WhereParam >) -> WhereParam { WhereParam :: YandexAuthIs (value) } pub fn is_not (value : Vec < yandex_auth :: WhereParam >) -> WhereParam { WhereParam :: YandexAuthIsNot (value) } pub enum Include { Select (Vec < yandex_auth :: SelectParam >) , Include (Vec < yandex_auth :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: YandexAuth (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("yandexAuth" , None , [] , selections) } pub fn select (nested_selections : Vec < yandex_auth :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < yandex_auth :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } pub enum Select { Select (Vec < yandex_auth :: SelectParam >) , Include (Vec < yandex_auth :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: YandexAuth (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("yandexAuth" , None , [] , selections) } pub fn select (nested_selections : Vec < yandex_auth :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < yandex_auth :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } } pub fn create (login : String , _params : Vec < SetParam >) -> (String , Vec < SetParam >) { (login , _params) } pub fn create_unchecked (login : String , _params : Vec < SetParam >) -> (String , Vec < SetParam >) { (login , _params) } # [macro_export] macro_rules ! _select_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: user :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: user :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , login , updated_at , yandex_auth } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: crate :: prisma :: user :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: user :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: user :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "login" , "updated_at" , "yandexAuth"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; login) => { String } ; (@ field_type ; updated_at) => { :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } ; (@ field_type ; yandex_auth : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < yandex_auth :: Data > } ; (@ field_type ; yandex_auth) => { Option < crate :: crate :: prisma :: yandex_auth :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "id, login, updated_at, yandex_auth")) } ; (@ field_module ; yandex_auth : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: prisma :: yandex_auth :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: prisma :: user :: SelectParam > :: into (crate :: crate :: prisma :: user :: id :: Select) } ; (@ selection_field_to_selection_param ; login) => { Into :: < crate :: crate :: prisma :: user :: SelectParam > :: into (crate :: crate :: prisma :: user :: login :: Select) } ; (@ selection_field_to_selection_param ; updated_at) => { Into :: < crate :: crate :: prisma :: user :: SelectParam > :: into (crate :: crate :: prisma :: user :: updated_at :: Select) } ; (@ selection_field_to_selection_param ; yandex_auth $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: prisma :: user :: SelectParam > :: into (crate :: crate :: prisma :: user :: yandex_auth :: Select :: $ selection_mode (crate :: crate :: prisma :: yandex_auth :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; yandex_auth $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: prisma :: user :: SelectParam > :: into (crate :: crate :: prisma :: user :: yandex_auth :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; login) => { "login" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; yandex_auth) => { "yandexAuth" } ; } pub use _select_user as select ; pub enum SelectParam { Id (id :: Select) , Login (login :: Select) , UpdatedAt (updated_at :: Select) , YandexAuth (yandex_auth :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Login (data) => data . to_selection () , Self :: UpdatedAt (data) => data . to_selection () , Self :: YandexAuth (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_user { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: user :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: user :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: user :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { yandex_auth } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub login : String , pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , $ (pub $ field : crate :: crate :: prisma :: user :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (login) , stringify ! (updated_at)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: user :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: prisma :: user :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: prisma :: user :: login :: NAME , & self . login) ? ; state . serialize_field (crate :: crate :: prisma :: user :: updated_at :: NAME , & self . updated_at) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , login , updated_at } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: user :: $ field :: NAME) , + , crate :: crate :: prisma :: user :: id :: NAME , crate :: crate :: prisma :: user :: login :: NAME , crate :: crate :: prisma :: user :: updated_at :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: user :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: prisma :: user :: id :: NAME => Ok (Field :: id) , crate :: crate :: prisma :: user :: login :: NAME => Ok (Field :: login) , crate :: crate :: prisma :: user :: updated_at :: NAME => Ok (Field :: updated_at) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut login = None ; let mut updated_at = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: user :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: login => { if login . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: user :: login :: NAME)) ; } login = Some (map . next_value () ?) ; } Field :: updated_at => { if updated_at . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: user :: updated_at :: NAME)) ; } updated_at = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: user :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: user :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: user :: id :: NAME)) ? ; let login = login . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: user :: login :: NAME)) ? ; let updated_at = updated_at . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: user :: updated_at :: NAME)) ? ; Ok (Data { id , login , updated_at , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "login" , "updated_at" , "yandexAuth"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: user :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; yandex_auth : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < yandex_auth :: Data > } ; (@ field_type ; yandex_auth) => { Option < crate :: crate :: prisma :: yandex_auth :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "User" , available relations are "yandex_auth")) } ; (@ field_module ; yandex_auth : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: prisma :: yandex_auth :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; yandex_auth $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: prisma :: user :: IncludeParam > :: into (crate :: crate :: prisma :: user :: yandex_auth :: Include :: $ selection_mode (crate :: crate :: prisma :: yandex_auth :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; yandex_auth $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: prisma :: user :: IncludeParam > :: into (crate :: crate :: prisma :: user :: yandex_auth :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: user :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; login) => { "login" } ; (@ field_serde_name ; updated_at) => { "updated_at" } ; (@ field_serde_name ; yandex_auth) => { "yandexAuth" } ; } pub use _include_user as include ; pub enum IncludeParam { Id (id :: Include) , Login (login :: Include) , UpdatedAt (updated_at :: Include) , YandexAuth (yandex_auth :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Login (data) => data . to_selection () , Self :: UpdatedAt (data) => data . to_selection () , Self :: YandexAuth (data) => data . to_selection () } } } # [macro_export] macro_rules ! _partial_unchecked_user { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: prisma :: user struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "login")] pub login : String , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > } [$ ($ scalar_field) , +] } } ; } pub use _partial_unchecked_user as partial_unchecked ; # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : String , # [serde (rename = "login")] pub login : String , # [serde (rename = "updated_at")] pub updated_at : :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > , # [serde (rename = "yandexAuth" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub yandex_auth : Option < Option < Box < super :: yandex_auth :: Data >> > } impl Data { pub fn yandex_auth (& self) -> Result < Option < & super :: yandex_auth :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . yandex_auth . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (yandex_auth))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } } # [derive (Clone)] pub enum WithParam { YandexAuth (super :: yandex_auth :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: YandexAuth (args) => { let mut selections = < super :: yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (yandex_auth :: NAME , None , [] , selections) } } } } # [derive (Clone)] pub enum SetParam { SetId (String) , SetLogin (String) , SetUpdatedAt (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , ConnectYandexAuth (super :: yandex_auth :: UniqueWhereParam) , DisconnectYandexAuth } impl From < SetParam > for (String , :: prisma_client_rust :: PrismaValue) { fn from (param : SetParam) -> Self { match param { SetParam :: SetId (value) => (id :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetLogin (value) => (login :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetUpdatedAt (value) => (updated_at :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value)) , SetParam :: ConnectYandexAuth (where_param) => (yandex_auth :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: yandex_auth :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: DisconnectYandexAuth => (yandex_auth :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) } } } # [derive (Clone)] pub enum UncheckedSetParam { Id (String) , Login (String) , UpdatedAt (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) } impl From < UncheckedSetParam > for SetParam { fn from (param : UncheckedSetParam) -> Self { match param { UncheckedSetParam :: Id (value) => Self :: SetId (value) , UncheckedSetParam :: Login (value) => Self :: SetLogin (value) , UncheckedSetParam :: UpdatedAt (value) => Self :: SetUpdatedAt (value) } } } # [derive (Clone)] pub enum OrderByParam { Id (:: prisma_client_rust :: Direction) , Login (:: prisma_client_rust :: Direction) , UpdatedAt (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: Id (direction) => (id :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Login (direction) => (login :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: UpdatedAt (direction) => (updated_at :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (_prisma :: read_filters :: StringFilter) , Login (_prisma :: read_filters :: StringFilter) , UpdatedAt (_prisma :: read_filters :: DateTimeFilter) , YandexAuthIsNull , YandexAuthIs (Vec < super :: yandex_auth :: WhereParam >) , YandexAuthIsNot (Vec < super :: yandex_auth :: WhereParam >) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Login (value) => (login :: NAME , value . into ()) , Self :: UpdatedAt (value) => (updated_at :: NAME , value . into ()) , Self :: YandexAuthIsNull => (yandex_auth :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: YandexAuthIs (where_params) => (yandex_auth :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: YandexAuthIsNot (where_params) => (yandex_auth :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name , value . into ()) } } # [derive (Clone)] pub enum UniqueWhereParam { LoginEquals (String) , IdEquals (String) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: LoginEquals (value) => Self :: Login (_prisma :: read_filters :: StringFilter :: Equals (value)) , UniqueWhereParam :: IdEquals (value) => Self :: Id (_prisma :: read_filters :: StringFilter :: Equals (value)) } } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (login :: NAME) , :: prisma_client_rust :: sel (updated_at :: NAME)] } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client , _where) } pub fn create (self , login : String , mut _params : Vec < SetParam >) -> Create < 'a > { _params . extend ([login :: set (login)]) ; Create :: new (self . client , _params) } pub fn create_unchecked (self , login : String , mut _params : Vec < UncheckedSetParam >) -> Create < 'a > { _params . extend ([login :: set (login)]) ; Create :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (login , mut _params) : (String , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . extend ([login :: set (login)]) ; Upsert :: new (self . client , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client , _where) } } } pub mod yandex_auth { use super :: * ; use super :: _prisma :: * ; pub const NAME : & str = "YandexAuth" ; pub mod token_type { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "token_type" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetTokenType (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: TokenType (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: TokenType (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: TokenType (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , TokenType , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: TokenType (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: TokenType (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod access_token { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "access_token" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetAccessToken (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: AccessToken (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: AccessToken (direction) } pub fn equals < T : From < UniqueWhereParam >> (value : String) -> T { UniqueWhereParam :: AccessTokenEquals (value) . into () } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , AccessToken , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: AccessToken (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: AccessToken (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod expires_in { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "expires_in" ; pub struct Set (pub i32) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetExpiresIn (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: ExpiresIn (v) } } pub fn set < T : From < Set >> (value : i32) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: ExpiresIn (direction) } pub fn equals (value : i32) -> WhereParam { WhereParam :: ExpiresIn (_prisma :: read_filters :: IntFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: IntFilter , ExpiresIn , { fn in_vec (_ : Vec < i32 >) -> InVec ; fn not_in_vec (_ : Vec < i32 >) -> NotInVec ; fn lt (_ : i32) -> Lt ; fn lte (_ : i32) -> Lte ; fn gt (_ : i32) -> Gt ; fn gte (_ : i32) -> Gte ; fn not (_ : i32) -> Not ; }) ; pub fn increment (value : i32) -> SetParam { SetParam :: IncrementExpiresIn (value) } pub fn decrement (value : i32) -> SetParam { SetParam :: DecrementExpiresIn (value) } pub fn multiply (value : i32) -> SetParam { SetParam :: MultiplyExpiresIn (value) } pub fn divide (value : i32) -> SetParam { SetParam :: DivideExpiresIn (value) } pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: ExpiresIn (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: ExpiresIn (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod refresh_token { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "refresh_token" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetRefreshToken (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: RefreshToken (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: RefreshToken (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: RefreshToken (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , RefreshToken , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: RefreshToken (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: RefreshToken (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod scope { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "scope" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetScope (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Scope (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Scope (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: Scope (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Scope , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Scope (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Scope (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod user { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "user" ; pub struct Fetch (pub user :: UniqueArgs) ; impl Fetch { pub fn with (mut self , params : impl Into < user :: WithParam >) -> Self { self . 0 = self . 0 . with (params . into ()) ; self } } impl From < Fetch > for WithParam { fn from (Fetch (v) : Fetch) -> Self { WithParam :: User (v) } } pub fn fetch () -> Fetch { Fetch (user :: UniqueArgs :: new ()) } pub struct Connect (user :: UniqueWhereParam) ; impl From < Connect > for SetParam { fn from (Connect (v) : Connect) -> Self { Self :: ConnectUser (v) } } pub fn connect < T : From < Connect >> (value : user :: UniqueWhereParam) -> T { Connect (value) . into () } pub fn disconnect () -> SetParam { SetParam :: DisconnectUser } pub fn is_null () -> WhereParam { WhereParam :: UserIsNull } pub fn is (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: UserIs (value) } pub fn is_not (value : Vec < user :: WhereParam >) -> WhereParam { WhereParam :: UserIsNot (value) } pub enum Include { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: User (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("user" , None , [] , selections) } pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } pub enum Select { Select (Vec < user :: SelectParam >) , Include (Vec < user :: IncludeParam >) , Fetch } impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: User (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { let selections = match self { Self :: Select (selections) => { selections . into_iter () . map (| s | s . to_selection ()) . collect () } , Self :: Include (selections) => { let mut nested_selections = vec ! [] ; nested_selections . extend (selections . into_iter () . map (| s | s . to_selection ())) ; nested_selections } , Self :: Fetch => { < user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () } } ; :: prisma_client_rust :: Selection :: new ("user" , None , [] , selections) } pub fn select (nested_selections : Vec < user :: SelectParam >) -> Self { Self :: Select (nested_selections) } pub fn include (nested_selections : Vec < user :: IncludeParam >) -> Self { Self :: Include (nested_selections) } } } pub mod user_id { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "userId" ; pub struct Set (pub Option < String >) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetUserId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: UserId (v) } } pub fn set < T : From < Set >> (value : Option < String >) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: UserId (direction) } pub fn equals < A , T : :: prisma_client_rust :: FromOptionalUniqueArg < Set , Arg = A >> (value : A) -> T { T :: from_arg (value) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringNullableFilter , UserId , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : Option < String >) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: UserId (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: UserId (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub fn create (token_type : String , access_token : String , expires_in : i32 , refresh_token : String , scope : String , _params : Vec < SetParam >) -> (String , String , i32 , String , String , Vec < SetParam >) { (token_type , access_token , expires_in , refresh_token , scope , _params) } pub fn create_unchecked (token_type : String , access_token : String , expires_in : i32 , refresh_token : String , scope : String , _params : Vec < SetParam >) -> (String , String , i32 , String , String , Vec < SetParam >) { (token_type , access_token , expires_in , refresh_token , scope , _params) } # [macro_export] macro_rules ! _select_yandex_auth { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: yandex_auth :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: yandex_auth :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: yandex_auth :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: yandex_auth :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: yandex_auth :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: yandex_auth :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { token_type , access_token , expires_in , refresh_token , scope , user , user_id } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: crate :: prisma :: yandex_auth :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["token_type" , "access_token" , "expires_in" , "refresh_token" , "scope" , "user" , "userId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: yandex_auth :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; token_type) => { String } ; (@ field_type ; access_token) => { String } ; (@ field_type ; expires_in) => { i32 } ; (@ field_type ; refresh_token) => { String } ; (@ field_type ; scope) => { String } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < user :: Data > } ; (@ field_type ; user) => { Option < crate :: crate :: prisma :: user :: Data > } ; (@ field_type ; user_id) => { Option < String > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "YandexAuth" , available relations are "token_type, access_token, expires_in, refresh_token, scope, user, user_id")) } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: prisma :: user :: select ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; token_type) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: token_type :: Select) } ; (@ selection_field_to_selection_param ; access_token) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: access_token :: Select) } ; (@ selection_field_to_selection_param ; expires_in) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: expires_in :: Select) } ; (@ selection_field_to_selection_param ; refresh_token) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: refresh_token :: Select) } ; (@ selection_field_to_selection_param ; scope) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: scope :: Select) } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: user :: Select :: $ selection_mode (crate :: crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: user :: Select :: Fetch) } } ; (@ selection_field_to_selection_param ; user_id) => { Into :: < crate :: crate :: prisma :: yandex_auth :: SelectParam > :: into (crate :: crate :: prisma :: yandex_auth :: user_id :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: yandex_auth :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; token_type) => { "token_type" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; expires_in) => { "expires_in" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; scope) => { "scope" } ; (@ field_serde_name ; user) => { "user" } ; (@ field_serde_name ; user_id) => { "userId" } ; } pub use _select_yandex_auth as select ; pub enum SelectParam { TokenType (token_type :: Select) , AccessToken (access_token :: Select) , ExpiresIn (expires_in :: Select) , RefreshToken (refresh_token :: Select) , Scope (scope :: Select) , User (user :: Select) , UserId (user_id :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: TokenType (data) => data . to_selection () , Self :: AccessToken (data) => data . to_selection () , Self :: ExpiresIn (data) => data . to_selection () , Self :: RefreshToken (data) => data . to_selection () , Self :: Scope (data) => data . to_selection () , Self :: User (data) => data . to_selection () , Self :: UserId (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_yandex_auth { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: yandex_auth :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: yandex_auth :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: yandex_auth :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: yandex_auth :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: yandex_auth :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: yandex_auth :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: yandex_auth :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { user } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub token_type : String , pub access_token : String , pub expires_in : i32 , pub refresh_token : String , pub scope : String , pub user_id : Option < String > , $ (pub $ field : crate :: crate :: prisma :: yandex_auth :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (token_type) , stringify ! (access_token) , stringify ! (expires_in) , stringify ! (refresh_token) , stringify ! (scope) , stringify ! (user_id)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: prisma :: yandex_auth :: token_type :: NAME , & self . token_type) ? ; state . serialize_field (crate :: crate :: prisma :: yandex_auth :: access_token :: NAME , & self . access_token) ? ; state . serialize_field (crate :: crate :: prisma :: yandex_auth :: expires_in :: NAME , & self . expires_in) ? ; state . serialize_field (crate :: crate :: prisma :: yandex_auth :: refresh_token :: NAME , & self . refresh_token) ? ; state . serialize_field (crate :: crate :: prisma :: yandex_auth :: scope :: NAME , & self . scope) ? ; state . serialize_field (crate :: crate :: prisma :: yandex_auth :: user_id :: NAME , & self . user_id) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , token_type , access_token , expires_in , refresh_token , scope , user_id } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME) , + , crate :: crate :: prisma :: yandex_auth :: token_type :: NAME , crate :: crate :: prisma :: yandex_auth :: access_token :: NAME , crate :: crate :: prisma :: yandex_auth :: expires_in :: NAME , crate :: crate :: prisma :: yandex_auth :: refresh_token :: NAME , crate :: crate :: prisma :: yandex_auth :: scope :: NAME , crate :: crate :: prisma :: yandex_auth :: user_id :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: prisma :: yandex_auth :: token_type :: NAME => Ok (Field :: token_type) , crate :: crate :: prisma :: yandex_auth :: access_token :: NAME => Ok (Field :: access_token) , crate :: crate :: prisma :: yandex_auth :: expires_in :: NAME => Ok (Field :: expires_in) , crate :: crate :: prisma :: yandex_auth :: refresh_token :: NAME => Ok (Field :: refresh_token) , crate :: crate :: prisma :: yandex_auth :: scope :: NAME => Ok (Field :: scope) , crate :: crate :: prisma :: yandex_auth :: user_id :: NAME => Ok (Field :: user_id) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut token_type = None ; let mut access_token = None ; let mut expires_in = None ; let mut refresh_token = None ; let mut scope = None ; let mut user_id = None ; while let Some (key) = map . next_key () ? { match key { Field :: token_type => { if token_type . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: token_type :: NAME)) ; } token_type = Some (map . next_value () ?) ; } Field :: access_token => { if access_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: access_token :: NAME)) ; } access_token = Some (map . next_value () ?) ; } Field :: expires_in => { if expires_in . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: expires_in :: NAME)) ; } expires_in = Some (map . next_value () ?) ; } Field :: refresh_token => { if refresh_token . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: refresh_token :: NAME)) ; } refresh_token = Some (map . next_value () ?) ; } Field :: scope => { if scope . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: scope :: NAME)) ; } scope = Some (map . next_value () ?) ; } Field :: user_id => { if user_id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: user_id :: NAME)) ; } user_id = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: $ field :: NAME)) ? ;) * let token_type = token_type . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: token_type :: NAME)) ? ; let access_token = access_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: access_token :: NAME)) ? ; let expires_in = expires_in . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: expires_in :: NAME)) ? ; let refresh_token = refresh_token . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: refresh_token :: NAME)) ? ; let scope = scope . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: scope :: NAME)) ? ; let user_id = user_id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: yandex_auth :: user_id :: NAME)) ? ; Ok (Data { token_type , access_token , expires_in , refresh_token , scope , user_id , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["token_type" , "access_token" , "expires_in" , "refresh_token" , "scope" , "user" , "userId"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: yandex_auth :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { Option < user :: Data > } ; (@ field_type ; user) => { Option < crate :: crate :: prisma :: user :: Data > } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "YandexAuth" , available relations are "user")) } ; (@ field_module ; user : $ selection_mode : ident { $ ($ selections : tt) + }) => { crate :: crate :: prisma :: user :: include ! (@ definitions ; ; $ ($ selections) +) ; } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? : $ selection_mode : ident { $ ($ selections : tt) + }) => { { Into :: < crate :: crate :: prisma :: yandex_auth :: IncludeParam > :: into (crate :: crate :: prisma :: yandex_auth :: user :: Include :: $ selection_mode (crate :: crate :: prisma :: user :: select ! (@ selections_to_params ; : $ selection_mode { $ ($ selections) + }) . into_iter () . collect ())) } } ; (@ selection_field_to_selection_param ; user $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ?) => { { Into :: < crate :: crate :: prisma :: yandex_auth :: IncludeParam > :: into (crate :: crate :: prisma :: yandex_auth :: user :: Include :: Fetch) } } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: yandex_auth :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; token_type) => { "token_type" } ; (@ field_serde_name ; access_token) => { "access_token" } ; (@ field_serde_name ; expires_in) => { "expires_in" } ; (@ field_serde_name ; refresh_token) => { "refresh_token" } ; (@ field_serde_name ; scope) => { "scope" } ; (@ field_serde_name ; user) => { "user" } ; (@ field_serde_name ; user_id) => { "userId" } ; } pub use _include_yandex_auth as include ; pub enum IncludeParam { TokenType (token_type :: Include) , AccessToken (access_token :: Include) , ExpiresIn (expires_in :: Include) , RefreshToken (refresh_token :: Include) , Scope (scope :: Include) , User (user :: Include) , UserId (user_id :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: TokenType (data) => data . to_selection () , Self :: AccessToken (data) => data . to_selection () , Self :: ExpiresIn (data) => data . to_selection () , Self :: RefreshToken (data) => data . to_selection () , Self :: Scope (data) => data . to_selection () , Self :: User (data) => data . to_selection () , Self :: UserId (data) => data . to_selection () } } } # [macro_export] macro_rules ! _partial_unchecked_yandex_auth { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: prisma :: yandex_auth struct $ struct_name { # [serde (rename = "token_type")] pub token_type : String , # [serde (rename = "access_token")] pub access_token : String , # [serde (rename = "expires_in")] pub expires_in : i32 , # [serde (rename = "refresh_token")] pub refresh_token : String , # [serde (rename = "scope")] pub scope : String , # [serde (rename = "userId")] # [serde (default , with = "::prisma_client_rust::serde::double_option")] pub user_id : Option < String > } [$ ($ scalar_field) , +] } } ; } pub use _partial_unchecked_yandex_auth as partial_unchecked ; # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "token_type")] pub token_type : String , # [serde (rename = "access_token")] pub access_token : String , # [serde (rename = "expires_in")] pub expires_in : i32 , # [serde (rename = "refresh_token")] pub refresh_token : String , # [serde (rename = "scope")] pub scope : String , # [serde (rename = "user" , default , skip_serializing_if = "Option::is_none" , with = "prisma_client_rust::serde::double_option")] pub user : Option < Option < Box < super :: user :: Data >> > , # [serde (rename = "userId")] pub user_id : Option < String > } impl Data { pub fn user (& self) -> Result < Option < & super :: user :: Data > , :: prisma_client_rust :: RelationNotFetchedError > { self . user . as_ref () . ok_or (:: prisma_client_rust :: RelationNotFetchedError :: new (stringify ! (user))) . map (| v | v . as_ref () . map (| v | v . as_ref ())) } } # [derive (Clone)] pub enum WithParam { User (super :: user :: UniqueArgs) } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { Self :: User (args) => { let mut selections = < super :: user :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections () ; selections . extend (args . with_params . into_iter () . map (Into :: < :: prisma_client_rust :: Selection > :: into)) ; :: prisma_client_rust :: Selection :: new (user :: NAME , None , [] , selections) } } } } # [derive (Clone)] pub enum SetParam { SetTokenType (String) , SetAccessToken (String) , SetExpiresIn (i32) , IncrementExpiresIn (i32) , DecrementExpiresIn (i32) , MultiplyExpiresIn (i32) , DivideExpiresIn (i32) , SetRefreshToken (String) , SetScope (String) , ConnectUser (super :: user :: UniqueWhereParam) , DisconnectUser , SetUserId (Option < String >) } impl From < SetParam > for (String , :: prisma_client_rust :: PrismaValue) { fn from (param : SetParam) -> Self { match param { SetParam :: SetTokenType (value) => (token_type :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetAccessToken (value) => (access_token :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetExpiresIn (value) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64)) , SetParam :: IncrementExpiresIn (value) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("increment" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: DecrementExpiresIn (value) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("decrement" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: MultiplyExpiresIn (value) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("multiply" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: DivideExpiresIn (value) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("divide" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))])) , SetParam :: SetRefreshToken (value) => (refresh_token :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetScope (value) => (scope :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: ConnectUser (where_param) => (user :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("connect" . to_string () , :: prisma_client_rust :: PrismaValue :: Object ([where_param] . into_iter () . map (Into :: < super :: user :: WhereParam > :: into) . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()))])) , SetParam :: DisconnectUser => (user :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: Object (vec ! [("disconnect" . to_string () , :: prisma_client_rust :: PrismaValue :: Boolean (true))])) , SetParam :: SetUserId (value) => (user_id :: NAME . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null)) } } } # [derive (Clone)] pub enum UncheckedSetParam { TokenType (String) , AccessToken (String) , ExpiresIn (i32) , RefreshToken (String) , Scope (String) , UserId (Option < String >) } impl From < UncheckedSetParam > for SetParam { fn from (param : UncheckedSetParam) -> Self { match param { UncheckedSetParam :: TokenType (value) => Self :: SetTokenType (value) , UncheckedSetParam :: AccessToken (value) => Self :: SetAccessToken (value) , UncheckedSetParam :: ExpiresIn (value) => Self :: SetExpiresIn (value) , UncheckedSetParam :: RefreshToken (value) => Self :: SetRefreshToken (value) , UncheckedSetParam :: Scope (value) => Self :: SetScope (value) , UncheckedSetParam :: UserId (value) => Self :: SetUserId (value) } } } # [derive (Clone)] pub enum OrderByParam { TokenType (:: prisma_client_rust :: Direction) , AccessToken (:: prisma_client_rust :: Direction) , ExpiresIn (:: prisma_client_rust :: Direction) , RefreshToken (:: prisma_client_rust :: Direction) , Scope (:: prisma_client_rust :: Direction) , UserId (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: TokenType (direction) => (token_type :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: AccessToken (direction) => (access_token :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: ExpiresIn (direction) => (expires_in :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: RefreshToken (direction) => (refresh_token :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Scope (direction) => (scope :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: UserId (direction) => (user_id :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , TokenType (_prisma :: read_filters :: StringFilter) , AccessToken (_prisma :: read_filters :: StringFilter) , ExpiresIn (_prisma :: read_filters :: IntFilter) , RefreshToken (_prisma :: read_filters :: StringFilter) , Scope (_prisma :: read_filters :: StringFilter) , UserIsNull , UserIs (Vec < super :: user :: WhereParam >) , UserIsNot (Vec < super :: user :: WhereParam >) , UserId (_prisma :: read_filters :: StringNullableFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: TokenType (value) => (token_type :: NAME , value . into ()) , Self :: AccessToken (value) => (access_token :: NAME , value . into ()) , Self :: ExpiresIn (value) => (expires_in :: NAME , value . into ()) , Self :: RefreshToken (value) => (refresh_token :: NAME , value . into ()) , Self :: Scope (value) => (scope :: NAME , value . into ()) , Self :: UserIsNull => (user :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Value (:: prisma_client_rust :: PrismaValue :: Null)) , Self :: UserIs (where_params) => (user :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("is" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: UserIsNot (where_params) => (user :: NAME , :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("isNot" . to_string () , :: prisma_client_rust :: PrismaValue :: Object (where_params . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (:: prisma_client_rust :: SerializedWhereInput :: transform_equals) . collect ()) ,)])) , Self :: UserId (value) => (user_id :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name , value . into ()) } } # [derive (Clone)] pub enum UniqueWhereParam { AccessTokenEquals (String) , UserIdEquals (String) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: AccessTokenEquals (value) => Self :: AccessToken (_prisma :: read_filters :: StringFilter :: Equals (value)) , UniqueWhereParam :: UserIdEquals (value) => Self :: UserId (_prisma :: read_filters :: StringNullableFilter :: Equals (Some (value))) } } } impl :: prisma_client_rust :: FromOptionalUniqueArg < user_id :: Set > for WhereParam { type Arg = Option < String > ; fn from_arg (arg : Self :: Arg) -> Self where Self : Sized { Self :: UserId (_prisma :: read_filters :: StringNullableFilter :: Equals (arg)) } } impl :: prisma_client_rust :: FromOptionalUniqueArg < user_id :: Set > for UniqueWhereParam { type Arg = String ; fn from_arg (arg : Self :: Arg) -> Self where Self : Sized { Self :: UserIdEquals (arg) } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (token_type :: NAME) , :: prisma_client_rust :: sel (access_token :: NAME) , :: prisma_client_rust :: sel (expires_in :: NAME) , :: prisma_client_rust :: sel (refresh_token :: NAME) , :: prisma_client_rust :: sel (scope :: NAME) , :: prisma_client_rust :: sel (user_id :: NAME)] } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client , _where) } pub fn create (self , token_type : String , access_token : String , expires_in : i32 , refresh_token : String , scope : String , mut _params : Vec < SetParam >) -> Create < 'a > { _params . extend ([token_type :: set (token_type) , access_token :: set (access_token) , expires_in :: set (expires_in) , refresh_token :: set (refresh_token) , scope :: set (scope)]) ; Create :: new (self . client , _params) } pub fn create_unchecked (self , token_type : String , access_token : String , expires_in : i32 , refresh_token : String , scope : String , mut _params : Vec < UncheckedSetParam >) -> Create < 'a > { _params . extend ([token_type :: set (token_type) , access_token :: set (access_token) , expires_in :: set (expires_in) , refresh_token :: set (refresh_token) , scope :: set (scope)]) ; Create :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (token_type , access_token , expires_in , refresh_token , scope , mut _params) : (String , String , i32 , String , String , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . extend ([token_type :: set (token_type) , access_token :: set (access_token) , expires_in :: set (expires_in) , refresh_token :: set (refresh_token) , scope :: set (scope)]) ; Upsert :: new (self . client , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client , _where) } } } pub mod torrent { use super :: * ; use super :: _prisma :: * ; pub const NAME : & str = "Torrent" ; pub mod id { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "id" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetId (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Id (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Id (direction) } pub fn equals < T : From < UniqueWhereParam >> (value : String) -> T { UniqueWhereParam :: IdEquals (value) . into () } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Id , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Id (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Id (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod name { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "name" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetName (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Name (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Name (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: Name (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Name , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Name (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Name (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod repacker { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "repacker" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetRepacker (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Repacker (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Repacker (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: Repacker (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Repacker , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Repacker (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Repacker (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub mod torrent { use super :: super :: * ; use super :: { WhereParam , UniqueWhereParam , OrderByParam , WithParam , SetParam , UncheckedSetParam } ; use super :: _prisma :: * ; pub const NAME : & str = "torrent" ; pub struct Set (pub String) ; impl From < Set > for SetParam { fn from (Set (v) : Set) -> Self { Self :: SetTorrent (v) } } impl From < Set > for UncheckedSetParam { fn from (Set (v) : Set) -> Self { Self :: Torrent (v) } } pub fn set < T : From < Set >> (value : String) -> T { Set (value) . into () } pub fn order (direction : :: prisma_client_rust :: Direction) -> OrderByParam { OrderByParam :: Torrent (direction) } pub fn equals (value : String) -> WhereParam { WhereParam :: Torrent (_prisma :: read_filters :: StringFilter :: Equals (value)) } :: prisma_client_rust :: scalar_where_param_fns ! (_prisma :: read_filters :: StringFilter , Torrent , { fn in_vec (_ : Vec < String >) -> InVec ; fn not_in_vec (_ : Vec < String >) -> NotInVec ; fn lt (_ : String) -> Lt ; fn lte (_ : String) -> Lte ; fn gt (_ : String) -> Gt ; fn gte (_ : String) -> Gte ; fn contains (_ : String) -> Contains ; fn starts_with (_ : String) -> StartsWith ; fn ends_with (_ : String) -> EndsWith ; fn not (_ : String) -> Not ; }) ; pub struct Include ; impl Into < super :: IncludeParam > for Include { fn into (self) -> super :: IncludeParam { super :: IncludeParam :: Torrent (self) } } impl Include { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } pub struct Select ; impl Into < super :: SelectParam > for Select { fn into (self) -> super :: SelectParam { super :: SelectParam :: Torrent (self) } } impl Select { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { :: prisma_client_rust :: sel (NAME) } } } pub fn create (name : String , repacker : String , torrent : String , _params : Vec < SetParam >) -> (String , String , String , Vec < SetParam >) { (name , repacker , torrent , _params) } pub fn create_unchecked (name : String , repacker : String , torrent : String , _params : Vec < SetParam >) -> (String , String , String , Vec < SetParam >) { (name , repacker , torrent , _params) } # [macro_export] macro_rules ! _select_torrent { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: torrent :: select ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: torrent :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn select ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: torrent :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: torrent :: select ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: SelectType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: torrent :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: torrent :: select ! (@ selections_to_params ; : select { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () ,] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { id , name , repacker , torrent } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { $ (pub $ field : crate :: crate :: prisma :: torrent :: select ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) +] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: torrent :: $ field :: NAME , & self . $ field) ? ;) * state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: torrent :: $ field :: NAME) , + ,] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: torrent :: $ field :: NAME => Ok (Field :: $ field)) , * , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * while let Some (key) = map . next_key () ? { match key { $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: $ field :: NAME)) ? ;) * Ok (Data { $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "repacker" , "torrent"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: torrent :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; id) => { String } ; (@ field_type ; name) => { String } ; (@ field_type ; repacker) => { String } ; (@ field_type ; torrent) => { String } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Torrent" , available relations are "id, name, repacker, torrent")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; id) => { Into :: < crate :: crate :: prisma :: torrent :: SelectParam > :: into (crate :: crate :: prisma :: torrent :: id :: Select) } ; (@ selection_field_to_selection_param ; name) => { Into :: < crate :: crate :: prisma :: torrent :: SelectParam > :: into (crate :: crate :: prisma :: torrent :: name :: Select) } ; (@ selection_field_to_selection_param ; repacker) => { Into :: < crate :: crate :: prisma :: torrent :: SelectParam > :: into (crate :: crate :: prisma :: torrent :: repacker :: Select) } ; (@ selection_field_to_selection_param ; torrent) => { Into :: < crate :: crate :: prisma :: torrent :: SelectParam > :: into (crate :: crate :: prisma :: torrent :: torrent :: Select) } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: torrent :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; repacker) => { "repacker" } ; (@ field_serde_name ; torrent) => { "torrent" } ; } pub use _select_torrent as select ; pub enum SelectParam { Id (id :: Select) , Name (name :: Select) , Repacker (repacker :: Select) , Torrent (torrent :: Select) } impl SelectParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Name (data) => data . to_selection () , Self :: Repacker (data) => data . to_selection () , Self :: Torrent (data) => data . to_selection () } } } # [macro_export] macro_rules ! _include_torrent { ($ (($ ($ func_arg : ident : $ func_arg_ty : ty) , +) =>) ? $ module_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { # [allow (warnings)] pub mod $ module_name { crate :: crate :: prisma :: torrent :: include ! (@ definitions ; $ module_name ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; use super :: * ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: torrent :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } pub fn include ($ ($ ($ func_arg : $ func_arg_ty) , +) ?) -> Selection { Selection ([crate :: crate :: prisma :: torrent :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: torrent :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } } ; ({ $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { { crate :: crate :: prisma :: torrent :: include ! (@ definitions ; ; $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) +) ; pub struct Selection (Vec < :: prisma_client_rust :: Selection >) ; impl :: prisma_client_rust :: IncludeType for Selection { type Data = Data ; type ModelData = crate :: crate :: prisma :: torrent :: Data ; fn to_selections (self) -> Vec < :: prisma_client_rust :: Selection > { self . 0 } } Selection ([crate :: crate :: prisma :: torrent :: include ! (@ selections_to_params ; : include { $ ($ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) + }) . into_iter () . map (| p | p . to_selection ()) . collect :: < Vec < _ >> () , < crate :: crate :: prisma :: torrent :: Types as :: prisma_client_rust :: ModelTypes > :: scalar_selections ()] . into_iter () . flatten () . collect :: < Vec < _ >> ()) } } ; (@ definitions ; $ ($ module_name : ident) ? ; $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) +) => { # [allow (warnings)] enum Fields { } # [allow (warnings)] impl Fields { fn selections () { $ (let _ = Fields :: $ field ;) + } } # [allow (warnings)] # [derive (std :: fmt :: Debug , Clone)] pub struct Data { pub id : String , pub name : String , pub repacker : String , pub torrent : String , $ (pub $ field : crate :: crate :: prisma :: torrent :: include ! (@ field_type ; $ field $ (: $ selection_mode { $ ($ selections) + }) ?) ,) + } impl :: serde :: Serialize for Data { fn serialize < S > (& self , serializer : S) -> Result < S :: Ok , S :: Error > where S : :: serde :: Serializer , { use :: serde :: ser :: SerializeStruct ; let mut state = serializer . serialize_struct ("Data" , [$ (stringify ! ($ field) ,) + stringify ! (id) , stringify ! (name) , stringify ! (repacker) , stringify ! (torrent)] . len ()) ? ; $ (state . serialize_field (crate :: crate :: prisma :: torrent :: $ field :: NAME , & self . $ field) ? ;) * state . serialize_field (crate :: crate :: prisma :: torrent :: id :: NAME , & self . id) ? ; state . serialize_field (crate :: crate :: prisma :: torrent :: name :: NAME , & self . name) ? ; state . serialize_field (crate :: crate :: prisma :: torrent :: repacker :: NAME , & self . repacker) ? ; state . serialize_field (crate :: crate :: prisma :: torrent :: torrent :: NAME , & self . torrent) ? ; state . end () } } impl < 'de > :: serde :: Deserialize < 'de > for Data { fn deserialize < D > (deserializer : D) -> Result < Self , D :: Error > where D : :: serde :: Deserializer < 'de > , { # [allow (warnings)] enum Field { $ ($ field) , + , id , name , repacker , torrent } impl < 'de > :: serde :: Deserialize < 'de > for Field { fn deserialize < D > (deserializer : D) -> Result < Field , D :: Error > where D : :: serde :: Deserializer < 'de > , { struct FieldVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for FieldVisitor { type Value = Field ; fn expecting (& self , formatter : & mut :: std :: fmt :: Formatter) -> :: std :: fmt :: Result { formatter . write_str (& [$ (crate :: crate :: prisma :: torrent :: $ field :: NAME) , + , crate :: crate :: prisma :: torrent :: id :: NAME , crate :: crate :: prisma :: torrent :: name :: NAME , crate :: crate :: prisma :: torrent :: repacker :: NAME , crate :: crate :: prisma :: torrent :: torrent :: NAME] . into_iter () . collect :: < Vec < _ >> () . join (", ")) } fn visit_str < E > (self , value : & str) -> Result < Field , E > where E : :: serde :: de :: Error , { match value { $ (crate :: crate :: prisma :: torrent :: $ field :: NAME => Ok (Field :: $ field)) , * , crate :: crate :: prisma :: torrent :: id :: NAME => Ok (Field :: id) , crate :: crate :: prisma :: torrent :: name :: NAME => Ok (Field :: name) , crate :: crate :: prisma :: torrent :: repacker :: NAME => Ok (Field :: repacker) , crate :: crate :: prisma :: torrent :: torrent :: NAME => Ok (Field :: torrent) , _ => Err (:: serde :: de :: Error :: unknown_field (value , FIELDS)) , } } } deserializer . deserialize_identifier (FieldVisitor) } } struct DataVisitor ; impl < 'de > :: serde :: de :: Visitor < 'de > for DataVisitor { type Value = Data ; fn expecting (& self , formatter : & mut std :: fmt :: Formatter) -> std :: fmt :: Result { formatter . write_str ("struct Data") } fn visit_map < V > (self , mut map : V) -> Result < Data , V :: Error > where V : :: serde :: de :: MapAccess < 'de > , { $ (let mut $ field = None ;) * let mut id = None ; let mut name = None ; let mut repacker = None ; let mut torrent = None ; while let Some (key) = map . next_key () ? { match key { Field :: id => { if id . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: id :: NAME)) ; } id = Some (map . next_value () ?) ; } Field :: name => { if name . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: name :: NAME)) ; } name = Some (map . next_value () ?) ; } Field :: repacker => { if repacker . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: repacker :: NAME)) ; } repacker = Some (map . next_value () ?) ; } Field :: torrent => { if torrent . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: torrent :: NAME)) ; } torrent = Some (map . next_value () ?) ; } $ (Field :: $ field => { if $ field . is_some () { return Err (:: serde :: de :: Error :: duplicate_field (crate :: crate :: prisma :: torrent :: $ field :: NAME)) ; } $ field = Some (map . next_value () ?) ; }) * } } $ (let $ field = $ field . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: $ field :: NAME)) ? ;) * let id = id . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: id :: NAME)) ? ; let name = name . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: name :: NAME)) ? ; let repacker = repacker . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: repacker :: NAME)) ? ; let torrent = torrent . ok_or_else (|| serde :: de :: Error :: missing_field (crate :: crate :: prisma :: torrent :: torrent :: NAME)) ? ; Ok (Data { id , name , repacker , torrent , $ ($ field) , * }) } } const FIELDS : & 'static [& 'static str] = & ["id" , "name" , "repacker" , "torrent"] ; deserializer . deserialize_struct ("Data" , FIELDS , DataVisitor) } } $ ($ (pub mod $ field { crate :: crate :: prisma :: torrent :: $ selection_mode ! (@ field_module ; $ field : $ selection_mode { $ ($ selections) + }) ; }) ?) + } ; (@ field_type ; $ field : ident $ ($ tokens : tt) *) => { compile_error ! (stringify ! (Cannot include nonexistent relation $ field on model "Torrent" , available relations are "")) } ; (@ field_module ; $ ($ tokens : tt) *) => { } ; (@ selection_field_to_selection_param ; $ ($ tokens : tt) *) => { compile_error ! (stringify ! ($ ($ tokens) *)) } ; (@ selections_to_params ; : $ macro_name : ident { $ ($ field : ident $ (($ ($ filters : tt) +) $ (. $ arg : ident ($ ($ arg_params : tt) *)) *) ? $ (: $ selection_mode : ident { $ ($ selections : tt) + }) ?) + }) => { [$ (crate :: crate :: prisma :: torrent :: $ macro_name ! (@ selection_field_to_selection_param ; $ field $ (($ ($ filters) +) $ (. $ arg ($ ($ arg_params) *)) *) ? $ (: $ selection_mode { $ ($ selections) + }) ?) ,) +] } ; (@ filters_to_args ;) => { vec ! [] } ; (@ filters_to_args ; $ ($ t : tt) *) => { $ ($ t) * } ; (@ field_serde_name ; id) => { "id" } ; (@ field_serde_name ; name) => { "name" } ; (@ field_serde_name ; repacker) => { "repacker" } ; (@ field_serde_name ; torrent) => { "torrent" } ; } pub use _include_torrent as include ; pub enum IncludeParam { Id (id :: Include) , Name (name :: Include) , Repacker (repacker :: Include) , Torrent (torrent :: Include) } impl IncludeParam { pub fn to_selection (self) -> :: prisma_client_rust :: Selection { match self { Self :: Id (data) => data . to_selection () , Self :: Name (data) => data . to_selection () , Self :: Repacker (data) => data . to_selection () , Self :: Torrent (data) => data . to_selection () } } } # [macro_export] macro_rules ! _partial_unchecked_torrent { ($ struct_name : ident { $ ($ scalar_field : ident) + }) => { :: prisma_client_rust :: macros :: partial_unchecked ! { crate :: crate :: prisma :: torrent struct $ struct_name { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "repacker")] pub repacker : String , # [serde (rename = "torrent")] pub torrent : String } [$ ($ scalar_field) , +] } } ; } pub use _partial_unchecked_torrent as partial_unchecked ; # [derive (Debug , Clone , :: serde :: Serialize , :: serde :: Deserialize)] pub struct Data { # [serde (rename = "id")] pub id : String , # [serde (rename = "name")] pub name : String , # [serde (rename = "repacker")] pub repacker : String , # [serde (rename = "torrent")] pub torrent : String } impl Data { } # [derive (Clone)] pub enum WithParam { } impl Into < :: prisma_client_rust :: Selection > for WithParam { fn into (self) -> :: prisma_client_rust :: Selection { match self { } } } # [derive (Clone)] pub enum SetParam { SetId (String) , SetName (String) , SetRepacker (String) , SetTorrent (String) } impl From < SetParam > for (String , :: prisma_client_rust :: PrismaValue) { fn from (param : SetParam) -> Self { match param { SetParam :: SetId (value) => (id :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetName (value) => (name :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetRepacker (value) => (repacker :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) , SetParam :: SetTorrent (value) => (torrent :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (value)) } } } # [derive (Clone)] pub enum UncheckedSetParam { Id (String) , Name (String) , Repacker (String) , Torrent (String) } impl From < UncheckedSetParam > for SetParam { fn from (param : UncheckedSetParam) -> Self { match param { UncheckedSetParam :: Id (value) => Self :: SetId (value) , UncheckedSetParam :: Name (value) => Self :: SetName (value) , UncheckedSetParam :: Repacker (value) => Self :: SetRepacker (value) , UncheckedSetParam :: Torrent (value) => Self :: SetTorrent (value) } } } # [derive (Clone)] pub enum OrderByParam { Id (:: prisma_client_rust :: Direction) , Name (:: prisma_client_rust :: Direction) , Repacker (:: prisma_client_rust :: Direction) , Torrent (:: prisma_client_rust :: Direction) } impl Into < (String , :: prisma_client_rust :: PrismaValue) > for OrderByParam { fn into (self) -> (String , :: prisma_client_rust :: PrismaValue) { match self { Self :: Id (direction) => (id :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Name (direction) => (name :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Repacker (direction) => (repacker :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) , Self :: Torrent (direction) => (torrent :: NAME . to_string () , :: prisma_client_rust :: PrismaValue :: String (direction . to_string ())) } } } # [derive (Clone)] pub enum WhereParam { Not (Vec < WhereParam >) , Or (Vec < WhereParam >) , And (Vec < WhereParam >) , Id (_prisma :: read_filters :: StringFilter) , Name (_prisma :: read_filters :: StringFilter) , Repacker (_prisma :: read_filters :: StringFilter) , Torrent (_prisma :: read_filters :: StringFilter) } impl :: prisma_client_rust :: WhereInput for WhereParam { fn serialize (self) -> :: prisma_client_rust :: SerializedWhereInput { let (name , value) = match self { Self :: Not (value) => ("NOT" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Or (value) => ("OR" , :: prisma_client_rust :: SerializedWhereValue :: List (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . map (| v | vec ! [v]) . map (:: prisma_client_rust :: PrismaValue :: Object) . collect ()) ,) , Self :: And (value) => ("AND" , :: prisma_client_rust :: SerializedWhereValue :: Object (:: prisma_client_rust :: merge_fields (value . into_iter () . map (:: prisma_client_rust :: WhereInput :: serialize) . map (Into :: into) . collect ())) ,) , Self :: Id (value) => (id :: NAME , value . into ()) , Self :: Name (value) => (name :: NAME , value . into ()) , Self :: Repacker (value) => (repacker :: NAME , value . into ()) , Self :: Torrent (value) => (torrent :: NAME , value . into ()) } ; :: prisma_client_rust :: SerializedWhereInput :: new (name , value . into ()) } } # [derive (Clone)] pub enum UniqueWhereParam { IdEquals (String) } impl From < UniqueWhereParam > for WhereParam { fn from (value : UniqueWhereParam) -> Self { match value { UniqueWhereParam :: IdEquals (value) => Self :: Id (_prisma :: read_filters :: StringFilter :: Equals (value)) } } } impl From < :: prisma_client_rust :: Operator < Self >> for WhereParam { fn from (op : :: prisma_client_rust :: Operator < Self >) -> Self { match op { :: prisma_client_rust :: Operator :: Not (value) => Self :: Not (value) , :: prisma_client_rust :: Operator :: And (value) => Self :: And (value) , :: prisma_client_rust :: Operator :: Or (value) => Self :: Or (value) , } } } # [derive (Clone)] pub struct Types ; impl :: prisma_client_rust :: ModelTypes for Types { type Data = Data ; type Where = WhereParam ; type UncheckedSet = UncheckedSetParam ; type Set = SetParam ; type With = WithParam ; type OrderBy = OrderByParam ; type Cursor = UniqueWhereParam ; const MODEL : & 'static str = NAME ; fn scalar_selections () -> Vec < :: prisma_client_rust :: Selection > { vec ! [:: prisma_client_rust :: sel (id :: NAME) , :: prisma_client_rust :: sel (name :: NAME) , :: prisma_client_rust :: sel (repacker :: NAME) , :: prisma_client_rust :: sel (torrent :: NAME)] } } pub type UniqueArgs = :: prisma_client_rust :: UniqueArgs < Types > ; pub type ManyArgs = :: prisma_client_rust :: ManyArgs < Types > ; pub type Count < 'a > = :: prisma_client_rust :: Count < 'a , Types > ; pub type Create < 'a > = :: prisma_client_rust :: Create < 'a , Types > ; pub type CreateMany < 'a > = :: prisma_client_rust :: CreateMany < 'a , Types > ; pub type FindUnique < 'a > = :: prisma_client_rust :: FindUnique < 'a , Types > ; pub type FindMany < 'a > = :: prisma_client_rust :: FindMany < 'a , Types > ; pub type FindFirst < 'a > = :: prisma_client_rust :: FindFirst < 'a , Types > ; pub type Update < 'a > = :: prisma_client_rust :: Update < 'a , Types > ; pub type UpdateMany < 'a > = :: prisma_client_rust :: UpdateMany < 'a , Types > ; pub type Upsert < 'a > = :: prisma_client_rust :: Upsert < 'a , Types > ; pub type Delete < 'a > = :: prisma_client_rust :: Delete < 'a , Types > ; pub type DeleteMany < 'a > = :: prisma_client_rust :: DeleteMany < 'a , Types > ; # [derive (Clone)] pub struct Actions < 'a > { pub client : & 'a :: prisma_client_rust :: PrismaClientInternals , } impl < 'a > Actions < 'a > { pub fn find_unique (self , _where : UniqueWhereParam) -> FindUnique < 'a > { FindUnique :: new (self . client , _where . into ()) } pub fn find_first (self , _where : Vec < WhereParam >) -> FindFirst < 'a > { FindFirst :: new (self . client , _where) } pub fn find_many (self , _where : Vec < WhereParam >) -> FindMany < 'a > { FindMany :: new (self . client , _where) } pub fn create (self , name : String , repacker : String , torrent : String , mut _params : Vec < SetParam >) -> Create < 'a > { _params . extend ([name :: set (name) , repacker :: set (repacker) , torrent :: set (torrent)]) ; Create :: new (self . client , _params) } pub fn create_unchecked (self , name : String , repacker : String , torrent : String , mut _params : Vec < UncheckedSetParam >) -> Create < 'a > { _params . extend ([name :: set (name) , repacker :: set (repacker) , torrent :: set (torrent)]) ; Create :: new (self . client , _params . into_iter () . map (Into :: into) . collect ()) } pub fn update (self , _where : UniqueWhereParam , _params : Vec < SetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params , vec ! []) } pub fn update_unchecked (self , _where : UniqueWhereParam , _params : Vec < UncheckedSetParam >) -> Update < 'a > { Update :: new (self . client , _where . into () , _params . into_iter () . map (Into :: into) . collect () , vec ! []) } pub fn update_many (self , _where : Vec < WhereParam > , _params : Vec < SetParam >) -> UpdateMany < 'a > { UpdateMany :: new (self . client , _where , _params ,) } pub fn upsert (self , _where : UniqueWhereParam , (name , repacker , torrent , mut _params) : (String , String , String , Vec < SetParam >) , _update : Vec < SetParam >) -> Upsert < 'a > { _params . extend ([name :: set (name) , repacker :: set (repacker) , torrent :: set (torrent)]) ; Upsert :: new (self . client , _where . into () , _params , _update) } pub fn delete (self , _where : UniqueWhereParam) -> Delete < 'a > { Delete :: new (self . client , _where . into () , vec ! []) } pub fn delete_many (self , _where : Vec < WhereParam >) -> DeleteMany < 'a > { DeleteMany :: new (self . client , _where) } pub fn count (self , _where : Vec < WhereParam >) -> Count < 'a > { Count :: new (self . client , _where) } } } pub mod _prisma { pub struct PrismaClientBuilder { url : Option < String > , action_notifier : :: prisma_client_rust :: ActionNotifier , } impl PrismaClientBuilder { fn new () -> Self { Self { url : None , action_notifier : :: prisma_client_rust :: ActionNotifier :: new () } } pub fn with_url (mut self , url : String) -> Self { self . url = Some (url) ; self } pub async fn build (self) -> Result < PrismaClient , :: prisma_client_rust :: NewClientError > { let internals = :: prisma_client_rust :: PrismaClientInternals :: new (self . url , self . action_notifier , super :: DATAMODEL_STR) . await ? ; Ok (PrismaClient (internals)) } } pub struct PrismaClient (:: prisma_client_rust :: PrismaClientInternals) ; impl :: std :: fmt :: Debug for PrismaClient { fn fmt (& self , f : & mut :: std :: fmt :: Formatter < '_ >) -> :: std :: fmt :: Result { f . debug_struct ("PrismaClient") . finish () } } impl PrismaClient { pub fn _builder () -> PrismaClientBuilder { PrismaClientBuilder :: new () } pub fn _query_raw < T : :: prisma_client_rust :: Data > (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: QueryRaw < T > { :: prisma_client_rust :: QueryRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub fn _execute_raw (& self , query : :: prisma_client_rust :: Raw) -> :: prisma_client_rust :: ExecuteRaw { :: prisma_client_rust :: ExecuteRaw :: new (& self . 0 , query , super :: DATABASE_STR ,) } pub async fn _batch < 'batch , T : :: prisma_client_rust :: BatchContainer < 'batch , Marker > , Marker > (& self , queries : T) -> :: prisma_client_rust :: Result << T as :: prisma_client_rust :: BatchContainer < 'batch , Marker >> :: ReturnType > { :: prisma_client_rust :: batch (queries , & self . 0) . await } pub fn _transaction (& self) -> :: prisma_client_rust :: TransactionBuilder < Self > { :: prisma_client_rust :: TransactionBuilder :: _new (self , & self . 0) } pub async fn _migrate_deploy (& self) -> Result < () , :: prisma_client_rust :: migrations :: MigrateDeployError > { let res = :: prisma_client_rust :: migrations :: migrate_deploy (super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url ()) . await ; :: prisma_client_rust :: tokio :: time :: sleep (core :: time :: Duration :: from_millis (1)) . await ; res } pub async fn _migrate_resolve (& self , migration : & str) -> Result < () , :: prisma_client_rust :: migrations :: MigrateResolveError > { :: prisma_client_rust :: migrations :: migrate_resolve (migration , super :: DATAMODEL_STR , super :: MIGRATIONS_DIR , & self . 0 . url () ,) . await } pub fn _db_push (& self) -> :: prisma_client_rust :: migrations :: DbPush { :: prisma_client_rust :: migrations :: db_push (super :: DATAMODEL_STR , & self . 0 . url ()) } pub fn user (& self) -> super :: user :: Actions { super :: user :: Actions { client : & self . 0 , } } pub fn yandex_auth (& self) -> super :: yandex_auth :: Actions { super :: yandex_auth :: Actions { client : & self . 0 , } } pub fn torrent (& self) -> super :: torrent :: Actions { super :: torrent :: Actions { client : & self . 0 , } } } impl :: prisma_client_rust :: PrismaClient for PrismaClient { fn internals (& self) -> & :: prisma_client_rust :: PrismaClientInternals { & self . 0 } fn internals_mut (& mut self) -> & mut :: prisma_client_rust :: PrismaClientInternals { & mut self . 0 } fn with_tx_id (& self , tx_id : Option < :: prisma_client_rust :: query_core :: TxId >) -> Self { Self (self . 0 . with_tx_id (tx_id)) } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum SortOrder { # [serde (rename = "asc")] Asc , # [serde (rename = "desc")] Desc } impl ToString for SortOrder { fn to_string (& self) -> String { match self { Self :: Asc => "asc" . to_string () , Self :: Desc => "desc" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TorrentScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "name")] Name , # [serde (rename = "repacker")] Repacker , # [serde (rename = "torrent")] Torrent } impl ToString for TorrentScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Name => "name" . to_string () , Self :: Repacker => "repacker" . to_string () , Self :: Torrent => "torrent" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum TransactionIsolationLevel { # [serde (rename = "Serializable")] Serializable } impl ToString for TransactionIsolationLevel { fn to_string (& self) -> String { match self { Self :: Serializable => "Serializable" . to_string () } } } impl :: prisma_client_rust :: TransactionIsolationLevel for TransactionIsolationLevel { } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum UserScalarFieldEnum { # [serde (rename = "id")] Id , # [serde (rename = "login")] Login , # [serde (rename = "updated_at")] UpdatedAt } impl ToString for UserScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: Id => "id" . to_string () , Self :: Login => "login" . to_string () , Self :: UpdatedAt => "updated_at" . to_string () } } } # [derive (Debug , Clone , Copy , :: serde :: Serialize , :: serde :: Deserialize , PartialEq , Eq)] pub enum YandexAuthScalarFieldEnum { # [serde (rename = "token_type")] TokenType , # [serde (rename = "access_token")] AccessToken , # [serde (rename = "expires_in")] ExpiresIn , # [serde (rename = "refresh_token")] RefreshToken , # [serde (rename = "scope")] Scope , # [serde (rename = "userId")] UserId } impl ToString for YandexAuthScalarFieldEnum { fn to_string (& self) -> String { match self { Self :: TokenType => "token_type" . to_string () , Self :: AccessToken => "access_token" . to_string () , Self :: ExpiresIn => "expires_in" . to_string () , Self :: RefreshToken => "refresh_token" . to_string () , Self :: Scope => "scope" . to_string () , Self :: UserId => "userId" . to_string () } } } pub mod read_filters { # [derive (Clone)] pub enum StringFilter { Equals (String) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (String) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) } } } # [derive (Clone)] pub enum StringNullableFilter { Equals (Option < String >) , InVec (Vec < String >) , NotInVec (Vec < String >) , Lt (String) , Lte (String) , Gt (String) , Gte (String) , Contains (String) , StartsWith (String) , EndsWith (String) , Not (Option < String >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for StringNullableFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Contains (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("contains" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: StartsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("startsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: EndsWith (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("endsWith" . to_string () , :: prisma_client_rust :: PrismaValue :: String (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , value . map (| value | :: prisma_client_rust :: PrismaValue :: String (value)) . unwrap_or_else (|| :: prisma_client_rust :: PrismaValue :: Null))]) } } } # [derive (Clone)] pub enum DateTimeFilter { Equals (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , InVec (Vec < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > >) , NotInVec (Vec < :: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , > >) , Lt (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , Lte (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , Gt (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , Gte (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) , Not (:: prisma_client_rust :: chrono :: DateTime < :: prisma_client_rust :: chrono :: FixedOffset , >) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for DateTimeFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: DateTime (value)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: DateTime (value))]) } } } # [derive (Clone)] pub enum IntFilter { Equals (i32) , InVec (Vec < i32 >) , NotInVec (Vec < i32 >) , Lt (i32) , Lte (i32) , Gt (i32) , Gte (i32) , Not (i32) } impl Into < :: prisma_client_rust :: SerializedWhereValue > for IntFilter { fn into (self) -> :: prisma_client_rust :: SerializedWhereValue { match self { Self :: Equals (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("equals" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: InVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("in" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value as i64)) . collect ()))]) , Self :: NotInVec (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("notIn" . to_string () , :: prisma_client_rust :: PrismaValue :: List (value . into_iter () . map (| value | :: prisma_client_rust :: PrismaValue :: Int (value as i64)) . collect ()))]) , Self :: Lt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Lte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("lte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Gt (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gt" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Gte (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("gte" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) , Self :: Not (value) => :: prisma_client_rust :: SerializedWhereValue :: Object (vec ! [("not" . to_string () , :: prisma_client_rust :: PrismaValue :: Int (value as i64))]) } } } } } pub use _prisma :: * ;